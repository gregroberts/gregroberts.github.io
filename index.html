<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Packt Python Graph</title>
	<script type="text/javascript" src="static/js/jqueryv1.11.3/jqueryv1.11.3.min.js"></script>
	<script type="text/javascript" src="static/js/bootstrapv3.3.5/bootstrap.min.js"></script>
	<script type="text/javascript" src="static/js/Linkurious/sigma.min.js"></script>
	<script type="text/javascript" src="static/js/Linkurious/plugins/sigma.parsers.gexf.min.js"></script>
	<script type="text/javascript" src="static/js/Linkurious/plugins/sigma.renderers.customEdgeShapes.min.js"></script>
	<script type="text/javascript" src="static/js/Linkurious/plugins/sigma.renderers.halo.min.js"></script>
	<script type="text/javascript" src="static/js/Linkurious/plugins/sigma.helpers.graph.min.js"></script>
	<script src="static/js/Linkurious/plugins/sigma.plugins.tooltips.min.js"></script>
	<script src="static/js/Linkurious/plugins/sigma.plugins.animate.min.js"></script>
	<script src="static/js/Linkurious/plugins/sigma.plugins.filter.min.js"></script>
	<script src="static/js/Linkurious/plugins/sigma.layout.forceLink.min.js"></script>	
	<script src="static/js/Linkurious/plugins/sigma.plugins.locate.min.js"></script>
	<script src="static/js/Linkurious/plugins/sigma.plugins.poweredBy.min.js"></script>
	<link rel="stylesheet" type="text/css" href="static/css/bootstrap.min.css">
	<style type="text/css">
	  #container {
		max-width: 1500px;
		height: 850px;
		margin: auto;
		background-color: #2c3e50;
	  }

	.hidden {
	  display: none;
	  visibility: hidden;
	}    
	</style>
</head>
<body>
	<h1>Packt Python Graph</h1>
	<div class="container-full">
		<div class="row">
			<div class="col-lg-9">
				<div id="container"></div>
			</div>
			<div class="col-lg-3">
				<div id="control-pane">
					<h2>Graph Filters</h2>
					<div class="form-group">
				  		<label for="min-degree">Minimum Degree -<span id="min-degree-val">0</span></label>
				  			0 <input class="form-control" id="min-degree" type="range" min="0" max="0" value="0"> <span id="max-degree-value">0</span><br>
				  		<label for"min-edge">Minimum Edge Weight -<span id="min-edge-val">0</span></label>
				  			0 <input class="form-control" id="min-edge" step="0.01" type="range" min="0" max="0" value="0"> <span id="max-edge-value">0</span><br>
				  		<label for="node-type">Node Type</label>
						<select class="form-control" id="node-type">
							<option value="" selected>All Types</option>
			  			</select>
				  		<label for="node-category">Node Category</label>
						<select class="form-control" id="node-category">
							<option value="" selected>All Categories</option>
			  			</select>
				  		<label for="node-search">Text Search</label>
				  		<input class="form-control" id="node-search" type="text">
					</div>	
					<span class="line"></span>
					<div class="btn-group" role="group">
				  		<button id="reset-btn" class="btn btn-primary">Reset filters</button>
				  		<button id="layout" class="btn btn-warning">Turn ForceLink Layout on/off
					</button>
					</div>
					
			  	</div>
			  	<div id="infoPanel">
			  	</div>	



			</div>
		</div>
	</div>

</div>
	

<script type="text/javascript">
s= new sigma({
	container: 'container',
	renderer: {
		container: document.getElementById('container'),
		type: 'canvas'
	},
	settings: {
		minNodeSize: 1,
		maxNodeSize: 7,
		minEdgeSize:0.1,
		maxEdgeSize:0.5,
		verbose:true,
		labelThreshold:5,  
		defaultEdgeType:"curve",
		defaultLabelColor: "#000",
		defaultLabelSize: 14,
		defaultLabelBGColor: "#ddd",
		defaultHoverLabelBGColor: "#002147",
		defaultLabelHoverColor: "#fff",
		nodeHaloColor: '#979696',
		edgeHaloColor: '#979696',
		nodeHaloSize: 10,
		edgeHaloSize: 10,
	    	zoomMin: 0.01,
	    	zoomMax: 10,	    	
	}
});
sigma.parsers.gexf(
	'static/data/Graph1.gexf',
	s,
	function(s) {
	// Initialize the Filter API
	filter = sigma.plugins.filter(s);
	$.getJSON('static/data/MetaData.json',
		function (data){
			s.graph.nodes().forEach(function (n){
				for (key in data[n.id]) {
					n.attributes[key]=data[n.id][key];
				};
			})
		updatePane(s.graph, filter);	
		}
	);
	
	function applyMinDegreeFilter(e) {
			var v = e.target.value;
			$('#min-degree-val').textContent = v;
			filter
			.undo('min-degree')
			.nodesBy(
				function(n, options) {
					return this.graph.degree(n.id) >= options.minDegreeVal;
				},{
					minDegreeVal: +v
				},
				'min-degree'
			)
			.apply();
	};
	function applyMinEdgeFilter(e) {
			var v = e.target.value;
			$('#min-edge-val').textContent = v;
			filter
			.undo('min-edge')
			.edgesBy(
				function(n, options) {
					return n.weight > options.weight
				},{
					weight: +v
				},
				'min-edge'
			)
			.apply();
	};	
	function applyTypeFilter(e) {
		var c = e.target[e.target.selectedIndex].value;
		filter
		.undo('node-type')
		.nodesBy(
			function(n, options) {
				return !c.length || n.attributes[options.property] === c;
			},{
				property: 'type'
			},
			'node-type'
		)
		.apply();
  	}
  	function applyCategoryFilter(e) {
		var c = e.target[e.target.selectedIndex].value;
		filter
		.undo('node-category')
		.nodesBy(
			function(n, options) {
				return !c.length || n.attributes[options.property] === c;
			},{
				property: 'category'
			},
			'node-category'
		)
		.apply();
  	}
 	function applySearchFilter(e) {
		var c = e.target.value;
		filter
		.undo('node-search')
		.nodesBy(
			function(n, options) {
				return n.label.toLowerCase().search(c) > -1;
			},
			{
				property: 'RAWR'
			},
			'node-search'
		)
		.apply();
  	}

  	$('#min-degree').change(applyMinDegreeFilter);  // for Chrome and FF
  	$('#min-edge').change(applyMinEdgeFilter); // for IE10+, that sucks  	
  	$('#node-type').change(applyTypeFilter);	
  	$('#node-category').change(applyCategoryFilter);
  	$('#node-search').change(applySearchFilter);	
 
	s.refresh();

	var hash = window.location.hash.replace('#','');
	if (hash!='') {locateNode(hash)};
	}
);

var conf = {
	animation: {
	node: {
	      duration: 800
	},
	edge: {
		duration: 800
	      },
	center: {
	      duration: 300
	}
	},
	//focusOut: true,
	zoomDef: 2
};	
var locate = sigma.plugins.locate(s,conf);
if (!s.settings('autoRescale')) {
	sigma.utils.zoomTo(s.camera, 0, 0, conf.zoomDef);
};

function locateNode (nid) {
	if (nid == '') {
		locate.center(1);
	}
	else {
    		locate.nodes(nid);
	}
};


function updatePane (graph, filter) {
	// get max degree
	var maxDegree = 0,
		maxEdge =0,
		types = {},
		categories = {};
	// read nodes
	graph.nodes().forEach(function(n) {
			maxDegree = Math.max(maxDegree, graph.degree(n.id));
			types[n.attributes.type] = true;
			if (n.attributes.category){
				categories[n.attributes.category] = true;
			}
			
	});
	graph.edges().forEach(function(n) {
		maxEdge = Math.max(maxEdge, n.weight)
	});

	// min degree
	$('#min-degree')[0].max = maxDegree;
	$('#max-degree-value').html(maxDegree);
	$('#min-edge')[0].max = maxEdge;
	$('#max-edge-value').html(maxEdge);

	// node category
	var nodecategoryElt = $('#node-type');
	Object.keys(types).forEach(function(c) {
			var optionElt = $("<option></option>");
			optionElt.append(c);
			nodecategoryElt.append(optionElt);
  	});

	var nodecategoryElt = $('#node-category');
	Object.keys(categories).forEach(function(c) {
			var optionElt = $("<option></option>");
			optionElt.append(c);
			nodecategoryElt.append(optionElt);
  	});


	// reset button
	  	$('#reset-btn').on("click", function(e) {
		$('#min-degree').val(0);
		$('#min-degree-val').html('0');
		$('#node-type').selectedIndex = 0;
		$('#node-category').selectedIndex = 0;
		$('#min-edge').val(0);
		$('#min-edge-val').html('0');	
		filter.undo().apply();
	  });

};

function renderHalo() {
  s.renderers[0].halo({
	nodes: s.graph.nodes()
  });
}


s.bind('clickNode', function(e) {
	
	var adjacentNodes = [],
		adjacentEdges = [];
	adjacentNodes = adjacentNodes.concat(s.graph.adjacentNodes(e.data.node.id));
	adjacentEdges = adjacentEdges.concat(s.graph.adjacentEdges(e.data.node.id));
	s.renderers[0].halo({
		nodes: adjacentNodes,
		edges: adjacentEdges
	});
	var meta  = e.data.node.attributes;
	console.log(meta);
	switch(meta['node type']){
		case 'topic':
			template = '<h3><a href="'+meta.url+'" target="blank">'+meta.name+'</a></h3>';
			template +='<b>A StackOverflow Tag with '+meta.size+' questions</b><hr>';	
			template += '<p>'+meta['one liner']+'</p>(Taken from the StackOverflow wiki page)<br>';
			template += '<b><a href="'+meta.url+'" target="blank">Read More</a></b>';
		break;
		case 'books':
			template = '<h3><a href="'+meta.url+'" target="blank">'+meta.title+'</a></h3>';
			template +='<b> An Awesome Packt Book';
			if (meta.authors != 'NULL') {
				template += ' written by '+meta.authors.replace(',',' and ');
			}
			template += '</b><hr>';
			template += '<p>'+meta['one liner']+'</p>';
			template +='<br>Page count: </b>'+meta['page count']+'<br>';
			template += '<br>Published:</b> '+meta['publication date']+'<br>';
			//put CTA here?
		break;
		case 'videos':
			template = '<h3><a href="'+meta.url+'" target="blank">'+meta.title+'</a></h3>';
			template +='<b> An Awesome Packt Video';
			if (meta.authors != 'NULL') {
				template += ' written by '+meta.authors.replace(',',' and ');
			}
			template += '</b><hr>';
			template += '<p>'+meta['one liner']+'</p>';
			template +='<br>Duration: </b>'+meta['page count']+'<br>';
			template += '<br>Published:</b> '+meta['publication date']+'<br>';
			//put CTA here?

		break;
		case 'blog':
			template = '<h3><a href="'+meta.url+'" target="blank">'+meta.title+'</a></h3>';
			template += '<b>A Blog written by '+meta.authors.replace(',',' and ')+'<hr>';
			template += '<br>Published:</b> '+meta['publication date']+'<br>';
			template += '<p>'+meta['one liner']+'</p>';
		break;
		case 'techprimer':
			template = '<h3><a href="'+meta.url+'" target="blank">'+meta.title+'</a></h3>';
			template += '<b>A Packt Tech Primer<hr>';
			template += '<br>Published:</b> '+meta['publication date']+'<br>';
			template += '<p>'+meta['one liner']+'</p>';
		break;

	};
	var related_topics = '<h4> Related Topics</h4><ul>';
	var related_titles = '<h4> Related Packt Content</h4><ul>';
	for (var i = adjacentNodes.length - 1; i >= 0; i--) {
		t = adjacentNodes[i];
		if( t.attributes.type=='topic') {
			related_topics += '<li><a class="locate" data-id="'+t.id+'">'+t.label +'</a></li>';
		}
		else {
			related_titles += '<li><a class="locate" data-id="'+t.id+'">'+t.label +'</a></li>';
		}
	};
	related_topics+='</ul>';
	related_titles += '</ul>';
	template += related_titles + related_topics;
	console.log(adjacentNodes);
	$('#infoPanel').empty().html(template);
	$('.locate').on('click', function(e){
		locateNode($(this).attr('data-id'));
	})
});

$('#layout').on('click',function () {
	var config = {
		linLogMode:true,
		barnesHutOptimize:true,
		alignNodeSiblings :true,

	}
	if (! sigma.layouts.isForceLinkRunning()) {
		sigma.layouts.startForceLink(s,{});
	} else {
		sigma.layouts.stopForceLink(s,{});
	};
})



</script>
</body>
</html>